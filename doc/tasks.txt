

Issues:
- non-stable generation seed across sessions, but stable in a session ("[WARN] seed map is empty!" is printed out)
- world generation progress is not displayed
- biome map generation is broken, square patterns!
- biome map is not saved to save files or loaded not correctly somehow!


Toolchain:
- version.json information for, loaded by the game & the tools:
    - version name & id
    - target mc version download url
    - stable or not
- installation.json storing local information like:
    - path to launcher
    - user name
    - path to mc asset folder / archive
- installer lookup for local mc installation -> use their .jar
- installer .jar file linking in the installation.json file instead of extraction
- obfuscator
- System to dynamically migrate code from deobf <-> obf and up versions [only simple changes]
- Better custom LaunchWrapper use system
- PyCharm launch Configuration setup handler for dev env and mdk

Library backend:
- upgrade to pyglet 2.0 [currently: 2.0dev2]

Data generation:
- attribute for data generator instances for name, so we don't need to set it at submitting, but in advance

Block Item Generator:
- improve, cleanup, prepare for removal & export to in-inventory rendering

Data driver:
- item, block, implementation for the other recipes

UI:
- system to create your own WorldGenerationMode, which is dumped to a save-based file
- registry view UI
- config UI
- mod list UI

Test System:
The test system is a external tool developed along the game sitting on top of it. It uses
a) The python import system, for loading single files and providing dummy files
b) The custom LaunchWrapper system, for launching the game in-code
c) The modding system, for injecting code into the game without needing LaunchWrapper directly
    [This can be used after with b) the LaunchWrapper is known-good]
    It would communicate via socket with the test process

Split into 4 parts:
- Unit tests: general functional tests
- Launch tests: tests executed during loading the game [registry injection tests, loading event tests, ...]
- User interaction tests: simulation of user input over the event system
- In-game tests: tests executed in-game automatically [see mc test framework], using structures and interaction paths
    for game behaviour, can be mixed with user interaction tests

